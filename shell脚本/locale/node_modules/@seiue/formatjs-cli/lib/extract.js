"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const babel = __importStar(require("@babel/core"));
const console_utils_1 = require("./console_utils");
const keyBy_1 = __importDefault(require("lodash/keyBy"));
const path_1 = require("path");
const fs_extra_1 = require("fs-extra");
const loader_utils_1 = require("loader-utils");
function getBabelConfig(filename, reactIntlOptions, extraBabelOptions = {}) {
    const fileExt = path_1.extname(filename);
    const isTS = fileExt === '.ts';
    const isTSX = fileExt === '.tsx';
    return Object.assign({ babelrc: false, parserOpts: {
            plugins: ['jsx'],
        }, presets: [
            ...(isTS || isTSX
                ? [['@babel/preset-typescript', { isTSX, allExtensions: true }]]
                : []),
            [
                '@babel/preset-env',
                {
                    targets: {
                        esmodules: true,
                    },
                },
            ],
        ], 
        // We need to use require.resolve here, or otherwise the lookup is based on the current working
        // directory of the CLI.
        plugins: [
            '@babel/plugin-proposal-class-properties',
            // We want to make sure that `const enum` does not throw an error.
            ...(isTS || isTSX ? [require.resolve('babel-plugin-const-enum')] : []),
            [require.resolve('@seiue/babel-plugin-react-intl'), reactIntlOptions],
        ], highlightCode: true, 
        // Extraction of string messages does not output the transformed JavaScript.
        sourceMaps: false }, extraBabelOptions);
}
function extractSingleFile(filename, extractOptions) {
    return babel.transformFileSync(filename, getBabelConfig(filename, extractOptions, { filename }));
}
function getReactIntlMessages(babelResult) {
    if (babelResult === null) {
        return {};
    }
    else {
        const messages = babelResult.metadata['react-intl'].messages;
        messages.forEach((m) => {
            m.filename = babelResult.options.filename;
        });
        return keyBy_1.default(messages, 'id');
    }
}
function getAppName(path) {
    const result = path.match(/.*\/apps\/([a-z\-]*)\/src\/.*/);
    return result ? result[1] : null;
}
function getPackageName(path) {
    const result = path.match(/.*\/packages\/src\/([a-z\-]*)\/.*/);
    return result ? result[1] : null;
}
function getFeatureName(path) {
    const result = path.match(/.*\/apps\/[a-z\-]*\/src\/features\/([a-z\-]+)\/.*/);
    return result ? result[1] : null;
}
async function extract(files, _a) {
    var { outFile, idInterpolationPattern } = _a, extractOpts = __rest(_a, ["outFile", "idInterpolationPattern"]);
    let babelOpts = extractOpts;
    if (outFile) {
        babelOpts.messagesDir = undefined;
    }
    const printMessagesToStdout = extractOpts.printMessagesToStdout !== undefined
        ? extractOpts.printMessagesToStdout
        : babelOpts.messagesDir == null && !outFile;
    let extractedMessages = {};
    if (files.length > 0) {
        for (const file of files) {
            if (idInterpolationPattern) {
                babelOpts = Object.assign(Object.assign({}, babelOpts), { overrideIdFn: (id, defaultMessage, description) => id ||
                        loader_utils_1.interpolateName({
                            resourcePath: file,
                        }, idInterpolationPattern, { content: `${defaultMessage}#${description}` }) });
            }
            const babelResult = extractSingleFile(file, babelOpts);
            const singleFileExtractedMessages = getReactIntlMessages(babelResult);
            // Aggregate result when we have to output to a single file
            if (outFile || printMessagesToStdout) {
                Object.entries(singleFileExtractedMessages).forEach(([key, message]) => {
                    const { filename } = message;
                    message.appName = getAppName(filename);
                    message.featureName = getFeatureName(filename);
                    message.packageName = getPackageName(filename);
                    const existMessage = extractedMessages[key];
                    // 如果不重复，直接赋值
                    if (!existMessage)
                        return (extractedMessages[key] = [message]);
                    extractedMessages[key].push(message);
                });
            }
        }
    }
    else {
        if (files.length === 0 && process.stdin.isTTY) {
            console_utils_1.warn('Reading source file from TTY.');
        }
        if (idInterpolationPattern) {
            babelOpts = Object.assign(Object.assign({}, babelOpts), { overrideIdFn: (id, defaultMessage, description) => id ||
                    loader_utils_1.interpolateName({
                        resourcePath: 'dummy',
                    }, idInterpolationPattern, { content: `${defaultMessage}#${description}` }) });
        }
        const stdinSource = await console_utils_1.getStdinAsString();
        const babelResult = babel.transformSync(stdinSource, getBabelConfig('<stdin>', babelOpts));
        if (printMessagesToStdout) {
            const singleFileExtractedMessages = getReactIntlMessages(babelResult);
            Object.entries(singleFileExtractedMessages).forEach(([key, message]) => {
                const { filename } = message;
                message.appName = getAppName(filename);
                message.featureName = getFeatureName(filename);
                message.packageName = getPackageName(filename);
                const existMessage = extractedMessages[key];
                // 如果不重复，直接赋值
                if (!existMessage)
                    return (extractedMessages[key] = [message]);
                extractedMessages[key].push(message);
            });
        }
    }
    if (outFile) {
        fs_extra_1.outputJSONSync(outFile, Object.values(extractedMessages), {
            spaces: 2,
        });
    }
    // 不需要这个控制台输出
    // if (printMessagesToStdout) {
    //   process.stdout.write(
    //     JSON.stringify(Object.values(extractedMessages), null, 2)
    //   );
    //   process.stdout.write('\n');
    // }
    return extractedMessages;
}
exports.default = extract;
//# sourceMappingURL=extract.js.map