"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _core = require("@babel/core");

var _generator = _interopRequireDefault(require("@babel/generator"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _default = {
  TSEnumDeclaration(path) {
    if (path.node.const) {
      path.replaceWith(_core.types.variableDeclaration('const', [_core.types.variableDeclarator(_core.types.identifier(path.node.id.name), _core.types.objectExpression(TSEnumMembersToObjectProperties(path.get('members'))))]));
      path.skip();
    }
  }

};
exports.default = _default;

const TSEnumMembersToObjectProperties = memberPaths => {
  const isStringEnum = memberPaths.some(memberPath => _core.types.isStringLiteral(memberPath.node.initializer));
  const constEnum = {};
  let currentValue = 0;
  return memberPaths.map(tsEnumMemberPath => {
    const tsEnumMember = tsEnumMemberPath.node;
    let value;
    let valueNode;

    if (tsEnumMember.initializer) {
      if (_core.types.isNumericLiteral(tsEnumMember.initializer) || _core.types.isStringLiteral(tsEnumMember.initializer)) {
        value = tsEnumMember.initializer.value;
      } else if (_core.types.isIdentifier(tsEnumMember.initializer)) {
        value = constEnum[tsEnumMember.initializer.name];
        validateConstEnumMemberAccess(tsEnumMemberPath, value);
      } else if (isNumericUnaryExpression(tsEnumMember.initializer) || isNumericBinaryExpression(tsEnumMember.initializer)) {
        if (isStringEnum) {
          throw tsEnumMemberPath.buildCodeFrameError('Computed values are not permitted in an enum with string valued members.');
        }

        tsEnumMemberPath.get('initializer').traverse(evalConstEnumMemberAccessVisitor, {
          constEnum
        });
        value = eval((0, _generator.default)(tsEnumMember.initializer).code);
      } else {
        throw tsEnumMemberPath.buildCodeFrameError('Enum initializer must be a string literal or numeric expression.');
      }
    } else {
      if (currentValue === null) {
        throw tsEnumMemberPath.buildCodeFrameError('Enum member must have initializer..');
      }

      value = currentValue;
    }

    constEnum[tsEnumMember.id.name] = value;

    if (Number.isFinite(value)) {
      valueNode = _core.types.numericLiteral(value);
      currentValue = value + 1;
    } else if (typeof value === 'string') {
      valueNode = _core.types.stringLiteral(value);
      currentValue = null;
    } else {
      // Should not get here.
      throw new Error('`value` is not a numer or string');
    }

    return _core.types.objectProperty(_core.types.identifier(tsEnumMember.id.name), valueNode);
  });
};

const isNumericUnaryExpression = node => _core.types.isUnaryExpression(node) && new Set(['+', '-', '~']).has(node.operator);

const isNumericBinaryExpression = node => _core.types.isBinaryExpression(node) && new Set(['+', '-', '/', '%', '*', '**', '&', '|', '>>', '>>>', '<<', '^']).has(node.operator);

const validateConstEnumMemberAccess = (path, value) => {
  if (value === undefined) {
    throw path.buildCodeFrameError('Enum initializer identifier must reference a previously defined enum member.');
  }
};

const evalConstEnumMemberAccessVisitor = {
  enter(path) {
    if (_core.types.isIdentifier(path.node)) {
      const constEnum = this.constEnum;
      const value = constEnum[path.node.name];
      validateConstEnumMemberAccess(path, value);
      path.replaceWith(_core.types.numericLiteral(value));
      path.skip();
    } else if (!(_core.types.isNumericLiteral(path.node) || isNumericUnaryExpression(path.node) || isNumericBinaryExpression(path.node))) {
      throw path.buildCodeFrameError('Must be numeric expression.');
    }
  }

};