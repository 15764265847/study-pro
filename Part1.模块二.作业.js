// 一、最终执行结果是10，因为在函数调用的时候for循环已经执行完了，for循环执行完之后的i的值为10


// 二、报错，let关键字声明变量会有块级作用域（暂存死区），即在块级作用域中在声明变量之前就是用该变量会抛出错误


// 三、
let arr = [23, 12, 45, 90];
Math.min(...arr);


// 四、
// 1、var 变量声明，会存在声明提升，即在声明变量之前可以访问该变量，此时该变量值为undefined，直到执行到该语句时才会赋值
//    即在初始化完毕该变量时可以访问其值
// 2、let 变量声明，存在块级作用域，即暂存死区，在变量声明之前访问该变量会抛出错误
// 3、const 常量声明，同let会存在块级作用域，声明基本值后，该常量值不可改变，但是声明引用值，其引用地址不可改改变
//    但是其成员，及成员的值可以改变


// 五、
// 输出20
// 原因：箭头函数的this只想取决其外部作用域中的this指向，obj.fn()调用时，fn中的this指向为obj，那么此时内部箭头函数的this指向也为obj


// 六、
// 1、唯一key
// 2、部分常量，例Symbol.iterator，定义迭代器函数


// 七、
let obj = { a: 1, b: 2, c: { d: 10 } };
// 1、浅拷贝 以上述obj为例，浅拷贝遇到基础值时会复制基础值，遇到引用值只会复制其引用，即赋值之后的引用值修改，原对象的引用值也会修改
// 2、深拷贝 即let obj2 = JSON.parse(JSON.stringify(obj));obj2中的成员c和原对象的c没关系，是两个引用，堆中分别存在


// 八、
// TS时js的超集，即TS在js的基础上实现了类型约束，所以在TS中也可以像平时写js一样直接写


// 九、引用计数优缺点
// 优点： 1、发现垃圾时可以立即对引用计数为0的展开回收  2、最大程度的减少程序的卡顿
// 缺点： 1、循环引用无法回收  2、内存开销大，因为维护计数器


// 十：
// 1、标记所有的可达对象
// 2、移动所有的可达对象，使其地址连续
// 3、对非可达对象的地址进行回收