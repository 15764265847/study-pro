// 一、最终执行结果是10，因为在函数调用的时候for循环已经执行完了，for循环执行完之后的i的值为10


// 二、报错，let关键字声明变量会有块级作用域（暂存死区），即在块级作用域中在声明变量之前就是用该变量会抛出错误


// 三、
let arr = [23, 12, 45, 90];
Math.min(...arr);


// 四、
// 1、var 变量声明，会存在声明提升，即在声明变量之前可以访问该变量，此时该变量值为undefined，直到执行到该语句时才会赋值
//    即在初始化完毕该变量时可以访问其值
// 2、let 变量声明，存在块级作用域，即暂存死区，在变量声明之前访问该变量会抛出错误
// 3、const 常量声明，同let会存在块级作用域，声明基本值后，该常量值不可改变，但是声明引用值，其引用地址不可改改变
//    但是其成员，及成员的值可以改变


// 五、
// 输出20
// 原因：箭头函数的this只想取决其外部作用域中的this指向，obj.fn()调用时，fn中的this指向为obj，那么此时内部箭头函数的this指向也为obj


// 六、
// 1、唯一key
// 2、部分常量，例Symbol.iterator，定义迭代器函数


// 七、
let obj = { a: 1, b: 2, c: { d: 10 } };
// 1、浅拷贝 以上述obj为例，浅拷贝遇到基础值时会复制基础值，遇到引用值只会复制其引用，即赋值之后的引用值修改，原对象的引用值也会修改
// 2、深拷贝 即let obj2 = JSON.parse(JSON.stringify(obj));obj2中的成员c和原对象的c没关系，是两个引用，堆中分别存在


// 八、
// TS时js的超集，即TS在js的基础上实现了类型约束以及对es6的支持，所以在TS中也可以像平时写js一样直接写


// 九、
// 优点：1、减少代码中碰到的类型异常，提高编码效率
//      2、增强代码的可靠性
// 缺点：1、没使用过其他强类型语言的话，需要一定的学习成本，因为多了很多概念
//      2、没有js本身灵活
//      3、编写小型项目会多一定的成本，因为需要添加一些interface，enum，泛型甚至是抽象类（abstract）


// 十、引用计数优缺点
// 优点： 1、发现垃圾时可以立即对引用计数为0的展开回收  2、最大程度的减少程序的卡顿
// 缺点： 1、循环引用无法回收  2、内存开销大，因为维护计数器


// 十一：
// 1、标记所有的可达对象
// 2、移动所有的可达对象，使其地址连续
// 3、对非可达对象的地址进行回收

// 十二、新生代的存储区分为两个部分，激活状态的空间叫from，非激活状态的叫做to
// 1、标记所有活动对象，并移动使其地址连续
// 2、将所有的活动对象复制到to
// 3、释放掉from中的所有的对象
// 4、此时会发生一次from和to的互换，即原from空间被释放掉之后就是变成非激活状态变成to，原to空间因为存在活动对象所以处于激活状态变成from
// 此过程中发现经历过一轮垃圾回收后还活着的对象或者是发现to空间使用率达到了25%那么就是触发对象晋升，即将新生代对象移动至老生代


// 十三、
// 1、增量标记算法会在触发老生代垃圾回收的时候使用
// 2、(1)遍历一部分老生代中存储的对象进行标记
//    (2)将执行权交还给js主线程，等待主线程任务结束
//    (3)主线程任务结束后继续遍历标记，如此往复直至所有的活动对象标记完毕
//    (4)回收非活对象的空间