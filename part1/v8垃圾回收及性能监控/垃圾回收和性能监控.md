### 引用计数算法优缺点
      PS：发现计数为0只是其中某一个环节，当发现引用计数为0时认定他是垃圾，然后开始GC
      优点：1、发现计数为0的对象会立即对空间进行释放
         2、最大限度的减少程序的暂停
      缺点：1、循环应用的空无法释放
         2、维护一个计数器内存开销较大

### v8垃圾回收机制：分代回收    
   PS：一般会按照固定的时间间隔出发GC（垃圾回收机制），其实在不同的浏览器触发时机是不太一样的，
   原则上在局部上下文中使用完之后就会直接回收，闭包例外

### 标记清除优缺点：
   优点：解决循环引用的问题
   缺点：空间碎片化，所以v8引入了标记整理算法来解决空间碎片化的问题，另外由于垃圾回收会占用主线程，即垃圾回收机制出发的时候主线程是无法工作的，所以v8会使用增量标记的算法来解决卡顿的问题

### 新生代垃圾回收机制：64位系统大小：32M   32位系统大小：16M
   新生代存储地址分为from空间和to空间，from空间处于激活状态，即大部分对象首先会存放在该空间，to空间处于非激活状态
   使用算法：空间复制，标记整理
   1、将所有的活动对象标记
   2、移动活动对象使其地址相连
   3、复制活动对象到to空间
   4、释放from空间
   注意：在释放from空间后会发生一次from和to的角色互换，即原from空间释放完毕之后变成非激活状态，变成to空间，原to空间因为存放了原from空间复制过来的活动对象变成激活状态成为from

### 对象晋升：在达到一定条件的时候，新生代存储空间中的对象会晋升老生代存储空间
   条件： 1、在经历过一轮GC之后还存活的对象
         2、当to空间使用率达到25%的时候

### 老生带对象垃圾回收机制：64位系统大小：1.4G   32位系统大小：700M
   使用算法：标记清除，标记整理，增量标记
   1、遍历所有老生代对象，并标记活动对象
   2、清除所有的非活动对象
   在出现对象晋升时发现老生代空间不足以存放晋升的对象时就会触发标记整理
      标记整理
      1、遍历标记所有的活动对象
      2、移动活动对象使其地址相连
      3、清空所有的非活对象释放空间
      增量标记
      即将标记清除拆分为多个步骤进行，先遍历一部分对象进行标记，然后执行权交还给js主线程，主线程任务完成后继续遍历，如此往复，直到遍历标记完所有的活动对象后进行空间释放

   何时会在老生代对象中出发标记整理算法：在新生代对象移动至老生带对象的时候，即发生对象晋升的时候，老生代存储空间不足以存储移动过来的新生代对象时，就会触发标记整理



内存膨胀，当出现持续性的糟糕的性能时候，也就是我们使用的软件在申请内存的时候，申请的内存空间远超过机器的内存空间的时候就是内存膨胀

性能问题的出现
1、内存膨胀 持续性的性能差 出现：当前的应用程序本身为了达到最优的使用效果，就需要更大的内存空间，此时就有可能出现内存膨胀
   1>有可能是设备本身的硬件就不支持
   测试方式：多种设备进行测试，如果表现的都很糟糕，那说明就是程序本身有问题不是设备的问题
2、内存泄漏 在使用的过程中，性能越来越差  出现：内存的持续升高，没有下降
3、频繁的垃圾回收  使用过程中频道卡顿
   通过内存变化图进行分析


内存监控方式
1、浏览器自带的任务管理器  更多工具-任务管理器  只能发现问题，而没法知道问题相关的脚本
   1>内存  一直在变化说明有频繁的DOM操作
   2>jsvascript内存  看的是小括号内的数值，如果内存一直增加，说明我们的程序有问题而不是GC（垃圾回收）
2、timeline时序图
3、对快照查找分离DOM
   开发者工具-内存，打开后默认第一个就是对快照功能，直接点击下方蓝色按钮就会看到堆的使用情况
   搜索detached就会看到DOM的堆使用情况，搜索出来的都是分离DOM
   PS：分离DOM就是不在DOM树中，但是又被我们引用甚至是进行操作的DOM元素
4、频繁的垃圾回收需要借助不同的工具查看内存的走势图
   频繁的垃圾回收会导致页面卡顿甚至是假死，因为垃圾回收的时候我们的脚本是停止运行的
   1>timeline中发现内存走势频繁的升高然后降低
   2>任务管理器中的数据频繁的增减减小


进准的测试js性能
   使用基于benchMach.js的http://www.jsperf.com/ 完成
   流程
   1、使用git登录
   2、个人信息，非必填
   3、测试用例  title slug  用于生成一个短连接
   4、填写准备代码   测试DOM操作时会经常用到
   5、填写必要的setup（前置操作）teardown（操作完成后的销毁）代码
   6、填写代码测试片段

为啥要慎用全局变量
   1、存在于最顶部作用域，查找耗时
   2、因为存在与全局上下文中，某些地方可能会用到，不会被垃圾回收机制回收掉，占用内存
   3、命名冲突，某个地方存在同明白能量的时候，变量污染